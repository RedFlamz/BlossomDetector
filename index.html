<!doctype html>
<html lang="en">
<head>
  <link rel="icon" href="lgo.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BlossomCraft — Downdetector</title>
<style>
  :root{
    --bg:#03102a; --card:#0b1220; --accent:#7dd3fc; --muted:#94a3b8;
    --ok:#10b981; --bad:#ef4444;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#03102a 0%,var(--bg) 100%);color:#e6eef8}
  
  /* Container adjustments for mobile/desktop */
  .wrap{max-width:980px;margin:32px auto;padding:20px}
  
  header{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  h1{margin:0;font-size:22px}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:16px;border-radius:12px;margin-top:16px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  
  /* Prevent pills/buttons from squashing */
  .pill{padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px;white-space:nowrap;}
  .online{background:rgba(16,185,129,0.12);color:var(--ok);border:1px solid rgba(16,185,129,0.12)}
  .offline{background:rgba(239,68,68,0.08);color:var(--bad);border:1px solid rgba(239,68,68,0.06)}
  .muted{color:var(--muted);font-size:13px}
  
  /* Table Responsiveness */
  .table-wrapper {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* Smooth scroll on iOS */
    margin-top: 12px;
  }
  
  table{width:100%;border-collapse:collapse; min-width: 500px;} /* Min width ensures columns don't collapse too much */
  th,td{padding:10px;border-bottom:1px dashed rgba(255,255,255,0.03);font-size:14px;text-align:left}
  th{font-size:13px;color:var(--muted);font-weight:600}
  
  button{background:linear-gradient(180deg,var(--accent),#38bdf8);border:0;padding:8px 12px;border-radius:10px;color:#012;cursor:pointer;font-weight:700;white-space:nowrap;}
  a.link{color:var(--accent);text-decoration:none;font-weight:700}
  
  .small{font-size:13px;color:var(--muted)}
  .actionTiny{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px;cursor:pointer}
  
  /* MOTD styles */
  .motd { white-space:pre-wrap; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; font-size:14px; line-height:1.2; word-break: break-word; }
  .motd .mc-obf { letter-spacing:0.04em; display:inline-block; } 

  /* Mobile Specific Adjustments */
  @media(max-width: 760px){
    .wrap { margin: 0; padding: 16px; width: auto; }
    header { justify-content: center; text-align: center; margin-bottom: 24px; }
    .card { padding: 12px; margin-top: 12px; }
    h1 { font-size: 20px; }
    th, td { padding: 8px 6px; font-size: 13px; }
    .row { row-gap: 8px; } /* Tighten vertical gaps on mobile */
  }
</style>
</head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TXCD95MCM"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4TXCD95MCM');
</script>
<body>
  <div class="wrap">
    <header>
      <div>
        
        <img width=100px src="lgo.png">
        <p class="lead"></p>
      </div>
      
    </header>

    <!-- MAIN HUB (MC SERVER) -->
    <div class="card" id="hubCard">
      <div class="row">
        <div>
          <strong>Main Hub (Minecraft):</strong> <span id="hubHost">play.blossomcraft.org</span>
        </div>
        <div id="hubPill" class="pill muted">—</div>
        <div class="muted small" id="hubLast">Last checked: —</div>
        <div style="margin-left:auto" class="row" role="group" aria-label="Hub actions">
          <button id="hubCheckBtn">Check now</button>
          <button hidden=true id="hubConnectBtn" class="actionTiny" title="Open address">How to connect</button>
        </div>
      </div>

      <div class="table-wrapper">
        <table>
          <tr><th>MOTD</th><td id="hubMOTD" class="motd">—</td></tr>
          <tr><th>Players</th><td id="hubPlayers">—</td></tr>
          <tr><th>Version</th><td id="hubVersion">—</td></tr>
          <tr><th>API Latency</th><td id="hubLatency">—</td></tr>
        </table>
      </div>
    </div>

    <!-- WORLDS (SUB-SERVERS) -->
    <div class="card" id="worldsCard">
      <div class="row">
        <div><strong>Worlds (sub-servers)</strong></div>
        <div class="muted small" style="margin-left:auto">Shows website availability for each world</div>
      </div>

      <div class="table-wrapper">
        <table id="worldsTable" aria-live="polite">
          <thead>
            <tr>
              <th>World</th>
              <th>Hostname</th>
              <th>Status</th>
              <th>Latency</th>
              <th>Last check</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="worldsBody"></tbody>
        </table>
      </div>

      <div style="margin-top:10px" class="row">
        <button id="checkAllBtn">Check all now</button>
        <button id="clearHistoryBtn" class="actionTiny">Clear local history</button>
        <div class="muted small" style="margin-left:auto" id="worldsNote">No checks yet.</div>
      </div>
    </div>

  

<script>
(() => {
  // Config
  const HUB_HOST = 'play.blossomcraft.org';
  const HUB_API = `https://api.mcsrvstat.us/2/${HUB_HOST}`;
  const CHECK_INTERVAL_MS = 30_000;

  const WORLDS = [
    {name: 'Lotus', host: 'lotus.blossomcraft.org'},
    {name: 'Cherry', host: 'cherry.blossomcraft.org'},
    {name: 'Spirit', host: 'spirit.blossomcraft.org'},
    {name: 'Tulip', host: 'tulip.blossomcraft.org'}
  ];

  // Helpers
  const idFor = s => s.replace(/[^a-z0-9]/gi, '_');
  const nowISO = () => new Date().toISOString();
  const fmtTime = ts => new Date(ts).toLocaleString();
  const escapeHtml = s => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

  // Elements
  const hubPill = document.getElementById('hubPill');
  const hubLast = document.getElementById('hubLast');
  const hubMOTD = document.getElementById('hubMOTD');
  const hubPlayers = document.getElementById('hubPlayers');
  const hubVersion = document.getElementById('hubVersion');
  const hubLatency = document.getElementById('hubLatency');
  const hubCheckBtn = document.getElementById('hubCheckBtn');
  const hubConnectBtn = document.getElementById('hubConnectBtn');

  const worldsBody = document.getElementById('worldsBody');
  const checkAllBtn = document.getElementById('checkAllBtn');
  const worldsNote = document.getElementById('worldsNote');
  const clearHistoryBtn = document.getElementById('clearHistoryBtn');

  // Local history helpers (same as before)
  const MAX_HISTORY = 200;
  function histKey(host){ return 'mc_world_hist_' + host; }
  function loadHist(host){ try{ const raw = localStorage.getItem(histKey(host)); return raw ? JSON.parse(raw) : []; }catch(e){ return []; } }
  function saveHist(host, arr){ try{ localStorage.setItem(histKey(host), JSON.stringify(arr.slice(-MAX_HISTORY))); }catch(e){} }
  function pushHist(host, entry){ const arr = loadHist(host); arr.push(entry); saveHist(host, arr); }

  // Build worlds table rows
  function buildWorldRows(){
    worldsBody.innerHTML = '';
    WORLDS.forEach(w => {
      const id = idFor(w.host);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><strong>${escapeHtml(w.name)}</strong></td>
        <td><code>${escapeHtml(w.host)}</code></td>
        <td id="${id}_status">—</td>
        <td id="${id}_lat">—</td>
        <td id="${id}_time">—</td>
        <td><a id="${id}_open" class="link" target="_blank" rel="noopener">Open site</a></td>
      `;
      worldsBody.appendChild(tr);
      document.getElementById(id + '_open').href = 'https://' + w.host + '/';
    });
  }

  /* ------------------ MOTD formatting ------------------
     This converts Minecraft § codes into styled HTML.
     It supports:
       - color codes 0–9, a–f
       - formatting codes: l (bold), m (strikethrough), n (underline), o (italic), k (obfuscated), r (reset)
     Input can be:
       - motd.html (render directly)
       - motd.raw — array or string with § codes
       - motd.clean — fallback plain text lines
  ----------------------------------------------------- */

  // color map (Minecraft standard)
  const MC_COLORS = {
    '0':'#000000','1':'#0000AA','2':'#00AA00','3':'#00AAAA','4':'#AA0000','5':'#AA00AA','6':'#FFAA00','7':'#AAAAAA',
    '8':'#555555','9':'#5555FF','a':'#55FF55','b':'#55FFFF','c':'#FF5555','d':'#FF55FF','e':'#FFFF55','f':'#FFFFFF'
  };

  function parseMotdToHtml(motdObj){
    // prefer html provided by API
    if(motdObj && motdObj.html){
      // API-provided HTML should already contain formatting and line breaks.
      return motdObj.html;
    }

    // helper: process a single raw line with § codes
    function processLine(line){
      if(!line) return '';
      // We'll iterate over text and § codes building spans with active style
      const parts = line.split(/(§[0-9a-frlomnk])/i).filter(Boolean);
      // state
      let color = null;
      let bold = false, italic = false, underline = false, strike = false, obf = false;
      const out = [];

      function pushText(txt){
        if(txt === '') return;
        let spanStart = '<span';
        const styles = [];
        if(color) styles.push(`color:${color}`);
        if(bold) styles.push('font-weight:700');
        if(italic) styles.push('font-style:italic');
        if(underline) styles.push('text-decoration:underline');
        if(strike) styles.push('text-decoration:line-through');
        const styleAttr = styles.length ? ` style="${styles.join(';')}"` : '';
        // obfuscated: wrap in element with class and use JS to replace its contents
        if(obf){
          // wrap in span.mc-obf and mark data-obf to be processed
          out.push(`<span class="mc-obf"${styleAttr} data-obf>${escapeHtml(txt)}</span>`);
        } else {
          out.push(`<span${styleAttr}>${escapeHtml(txt)}</span>`);
        }
      }

      for(let i=0;i<parts.length;i++){
        const p = parts[i];
        if(/^§/i.test(p)){
          // code token
          const code = p[1].toLowerCase();
          // color codes reset formatting except for obf? According to MC, color resets formatting.
          if(/[0-9a-f]/i.test(code)){
            color = MC_COLORS[code] || null;
            // color resets style modifiers
            bold = italic = underline = strike = obf = false;
          } else if(code === 'r'){ // reset
            color = null; bold = italic = underline = strike = obf = false;
          } else if(code === 'l'){ bold = true; }
          else if(code === 'o'){ italic = true; }
          else if(code === 'n'){ underline = true; }
          else if(code === 'm'){ strike = true; }
          else if(code === 'k'){ obf = true; }
          // anything else ignored
        } else {
          // regular text chunk
          pushText(p);
        }
      }
      return out.join('');
    }

    // motd.raw may be an array of lines or a string; motd.clean is array of plain lines
    if(motdObj && motdObj.raw){
      const raw = Array.isArray(motdObj.raw) ? motdObj.raw : [motdObj.raw];
      const htmlLines = raw.map(l => processLine(l));
      return htmlLines.join('<br>');
    }

    if(motdObj && motdObj.clean){
      const clean = Array.isArray(motdObj.clean) ? motdObj.clean : [motdObj.clean];
      return clean.map(escapeHtml).join('<br>');
    }

    return '';
  }

  // when obfuscated spans exist, we replace their content with random glyphs (keeps length)
  function startObfuscationTicker(){
    // find all spans with data-obf and replace characters with random visually-similar chars
    function obfOnce(){
      const spans = document.querySelectorAll('.mc-obf[data-obf]');
      spans.forEach(s => {
        const text = s.getAttribute('data-orig') || s.textContent || '';
        // store original once
        if(!s.getAttribute('data-orig')) s.setAttribute('data-orig', text);
        const orig = s.getAttribute('data-orig') || '';
        // produce random replacement by choosing random characters from charset
        const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()[]{}<>;:.,';
        let out = '';
        for(let i=0;i<orig.length;i++){
          const ch = orig[i];
          if(/\s/.test(ch)) out += ch;
          else out += charset[Math.floor(Math.random()*charset.length)];
        }
        s.textContent = out;
      });
    }
    // run every 400ms to mimic MC obf
    setInterval(obfOnce, 400);
  }

  /* ------------------ Hub (MC server) check ------------------ */
  async function checkHub(){
    hubPill.textContent = 'checking…';
    hubPill.className = 'pill muted';
    hubLast.textContent = 'Last checked: …';
    const t0 = performance.now();
    try{
      const res = await fetch(HUB_API, {cache: 'no-store'});
      const latencyMs = Math.round(performance.now() - t0);
      const json = await res.json();
      const online = !!json.online;
      if(online){
        hubPill.textContent = 'ONLINE';
        hubPill.className = 'pill online';
        // format MOTD properly
        const motdHtml = parseMotdToHtml(json.motd || {});
        hubMOTD.innerHTML = motdHtml || '—';
        // start obf tick if needed
        if(document.querySelector('.mc-obf[data-obf]')) startObfuscationTicker();

        hubPlayers.textContent = (json.players?.online != null) ? `${json.players.online} / ${json.players.max ?? '?'}` : '—';
        hubVersion.textContent = json.version || json.software || '—';
        hubLatency.textContent = latencyMs + ' ms';
      } else {
        hubPill.textContent = 'OFFLINE';
        hubPill.className = 'pill offline';
        hubMOTD.textContent = '—';
        hubPlayers.textContent = '—';
        hubVersion.textContent = '—';
        hubLatency.textContent = '—';
      }
      hubLast.textContent = 'Last checked: ' + new Date().toLocaleString();
      pushHist(HUB_HOST, {ts: nowISO(), online, latency: latencyMs});
    } catch(e){
      hubPill.textContent = 'OFFLINE';
      hubPill.className = 'pill offline';
      hubLast.textContent = 'Last checked: ' + nowISO();
      hubMOTD.textContent = '—';
      hubPlayers.textContent = '—';
      hubVersion.textContent = '—';
      hubLatency.textContent = '—';
      pushHist(HUB_HOST, {ts: nowISO(), online: false, latency: null});
    }
  }

  /* ------------------ Website checks for worlds ------------------ */
  async function checkWorld(world){
    const id = idFor(world.host);
    const statusEl = document.getElementById(id + '_status');
    const latEl = document.getElementById(id + '_lat');
    const timeEl = document.getElementById(id + '_time');

    statusEl.textContent = 'checking…';
    statusEl.className = '';
    latEl.textContent = '—';
    timeEl.textContent = '—';

    const url = 'https://' + world.host + '/?cb=' + Math.random().toString(36).slice(2);
    const t0 = performance.now();
    try{
      const res = await fetch(url, {mode: 'no-cors', cache: 'no-store'});
      const latency = Math.round(performance.now() - t0);
      statusEl.textContent = 'ONLINE';
      statusEl.style.color = '';
      latEl.textContent = latency + ' ms';
      timeEl.textContent = new Date().toLocaleTimeString();
      pushHist(world.host, {ts: nowISO(), online: true, latency});
    } catch(err){
      statusEl.textContent = 'OFFLINE';
      latEl.textContent = '—';
      timeEl.textContent = new Date().toLocaleTimeString();
      pushHist(world.host, {ts: nowISO(), online: false, latency: null});
    }
    updateWorldsNote();
  }

  function checkAllWorlds(){
    WORLDS.forEach(w => checkWorld(w));
    updateWorldsNote();
  }

  function updateWorldsNote(){
    let onlineCount = 0;
    WORLDS.forEach(w => {
      const id = idFor(w.host);
      const st = document.getElementById(id + '_status');
      if(st && st.textContent && st.textContent.toLowerCase().includes('online')) onlineCount++;
    });
    worldsNote.textContent = `${onlineCount} / ${WORLDS.length} worlds online (based on last checks)`;
  }

  function clearAllHistory(){
    try{
      localStorage.removeItem(histKey(HUB_HOST));
      WORLDS.forEach(w => localStorage.removeItem(histKey(w.host)));
    }catch(e){}
    worldsNote.textContent = 'History cleared.';
    setTimeout(updateWorldsNote, 600);
  }

  // Wiring up UI & init
  hubCheckBtn.addEventListener('click', () => checkHub());
  hubConnectBtn.addEventListener('click', () => {
    alert('To join BlossomCraft in Minecraft client, open Multiplayer → Add Server, and use address:\\n' + HUB_HOST);
  });
  checkAllBtn.addEventListener('click', () => checkAllWorlds());
  clearHistoryBtn.addEventListener('click', clearAllHistory);

  buildWorldRows();
  checkHub();
  checkAllWorlds();
  setInterval(() => { checkHub(); checkAllWorlds(); }, CHECK_INTERVAL_MS);

})();
</script>
</body>
</html>
